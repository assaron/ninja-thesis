Возможности программы _gshell_
------------------------------

Пример процедуры работы пользователя с проектом _project-root_ при помощи _gshell_:

\begin{code}[language=bash,label=lst:dirdatatree,
                   caption={}]
$ gshell init project-root
$ gshell enter project-root
work-id8172 $ touch x
work-id8172 $ gshell exit
\end{code}

Изначально пользователь вызывает _gshell_ с аргументами *init* и названием проекта.
Это создает необходимые начальные файлы и папки. Создается папка проекта, .gshell, нулевая ревизия (в которой записываются пустые предки, пустое сообщение commit и время создания), в мастер ревизию она записывается.

Далее пользователь вызывает _gshell_ с аргументами *enter* и названием проекта.
Эта команда создает подпапку в папке проекта для новой сессии, берет мастер ревизию,
стоит дерево из всех ее предшественников (основываясь на файле parents), создает
новую ревизию, в которую будет писать новая сессия, монтирует при помощи _unionfs_
эту ветку в новосозданную папку сессии. Затем получив путь к рабочей директории,
делает эту папку активной для пользователя, то есть помещает его туда.

Затем пользователь может выполнять любые действия в данной сессии. За исключением действий по выходу из папки на уровни выше, так как это уже не будет управляться _gshell_.

Каждое действие пользователя сохраняется. То есть при выполнении команды фиксируется
состояние проекта, записывается команда только что выполненная как сообщение,
фиксируется время исполнению. Это нужно для того, что бы множество ревизий
отображало проект на фазе каждой команды. Имея множество состояний мы можем
перемещаться в любой момент работы. То есть если была сделана ошибка мы можем
"откатиться" назад, исправить ошибку и получить новое состояние системы без
прошлой оплошности. Это и позволяет нам в дальнейшем получать информацию о
том, что мы делали с тем или иным файлом. Поскольку в каждой ревизии фиксируется
какие файлы были изменены, на запрос об истории файла мы можем пройтись по всем ревизиям, которые используются в текущей сессии и по информации о доступе однозначно сказать, какие команды были использованы по отношению к объекту.

Когда пользователь получит необходимый результат он может выйти из программы оставив весь проект как есть. Но так же присутствует возможность удалить проект.

Человек может работать в проекте одновременно из нескольких терминалов. Это
было реализовано при помощи создания мастер ветки ревизий. Изначально, каждая
сессия не зависит от другой. Она имеет собственную историю и список используемых
ревизий. Но если пользователю нужно сделать данную ветку основной, то есть что бы
другие результаты были основаны на ней, он может добавить ее в мастер ветку. При
существовании конфликтов файлов происходит процесс объединения. Он прост --- тот
файл, что старше, будет заменен файлом, что моложе. Это реализовано за счет того,
что ревизии монтируются по времени создания (завершения команды, что записана в
качестве сообщения).

Ниже приведен список команд, которые пользователь может использовать:

* gshell init <путь к проекту> --- начальное создание проекта.
* gshell enter <путь к проекту> --- создание новой сессии для работы с проектом.
* gshell log --- просмотр истории для всей сессии.
* gshell log <путь к файлу> --- просмотр истории для заданного файла в рамках данной сессии.
* gshell push --- добавление текущей сессии в мастер ветку.
* gshell pull --- добавление ревизий из мастер ветки в текущую сессии.
* gshell exit --- выход из сессии.
* gshell off --- выключение функции автоматического фиксирование изменения файлов в сессии.
* gshell on --- включение функции автоматического фиксирование изменения файлов в сессии.
* gshell clear <путь  проекту> --- очистка проекта.
* gshell makefile <путь к файлу> --- создание makefile для воссоздания заданного файла.
* gshell rollback --- отмена предыдущей команды.
* gshell checkout <название ревизии> --- переход на конкретную ревизию.
* gshell graph --- вывод в формат png графа файлов и зависимостей между ревизий.

TODO Что еще?

Стоит отметить, что во время сессии команды _gshell_ не фиксируются в истории.

