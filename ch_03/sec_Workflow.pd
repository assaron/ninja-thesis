Механизм работы _gshell_
------------------------

Когда на вход программе подаются аргументы, перед тем как понять, что хочет пользователь,
_gshell_ всегда проверяет наличие папки проекта, и генерирует внутренее состояние на
основе ее содержимого.

Далее в зависимости от необходимого действия происходит вызов соответствующзей функции.
Ни одна из комманд не будет работать, если для ее осуществления отсутсвует, например
директория проекта. _gshell_ выдаст ошибку.

Поскольку было решено использовать монаду state с линзами, то код получился очень легко
читаем. Но в тоже время он сохраняет все свойства и плюсы функционального подхода.
То есть мы получили состояние (считали с диска), затем необходимым образом его изменили,
и только после этого, включая необходимые проверки, записали его обратно на диск, а так
же по необходимости выполнили и другие IO действия.

На \inlref{листинге}{lst:store-fs} мы можем видеть пример функции реализованной при
помощи данных библиотек и техник.

\begin{code}[language=Haskell,label=lst:commitcode,
                   caption={}]
commitGshell :: String -> FilePath -> StateT GState IO Result
commitGshell message currentWork = do
    lift $ unmountWorkspace currentWork
    workState <- getWorkState currentWork
    let parent = last $ workState ^. revisions
    setTimeStamp parent
    writeCommitMessage message parent
    revName <- createCommitDir $ Parents [parent]
    workState' <- gets $ WorkingState . generateBranch [revName]
    workingState (takeFileName currentWork) .= show workState'
    writeStateToDisk
    get >>= lift . createWorkspace currentWork (workState' ^. revisions)
\end{code}

### Монтирование ревизий ###

Для каждой сессии существует свой список ревизий, которые будут в ней использоваться.
Ревизии отсортированы по времени, и таким образом те из них, кто старше, будут являться
только для чтения. Самая последняя же, то есть самая новая --- будет для записи.
Это и обеспечивает возможность создания ревизии для каждого действия.
Если у нас в ревизии, что замонтирована для чтения есть файл, который пользователь
изменит -- измененная версия файла будет уже записана в новую ревизию, что
смонтирована для записи. Это реализованно с помощью программы _unionfs_.
Она обеспечивает copy-on-write технологию.

### Обновление сессии и фиксирование изменений ###

Когда пользователь используется проект под управлением _gshell_, он выполняет команды.
После каждой команды фиксируются изменения и обновляется текущая сессия. Обновление есть
создание новой ревизии и монтирование предыдущих только для чтения. Когда монтирование
завершено, для пользователя обновляется автоматически сама сессия. Это реализовано
при помощи командной оболочки UNIX _*ZSH*_. В нее добавляются необходимые операции,
которые выполняются после любых команд, при условии инициализированного и
включенного _gshell_.
