Внутреннее устройство _gshell_
------------------------------

### Базовая структура ###

Для обработки всей информации было решено состоянием программы сделать так же директории
и их содержимое. С помощью выше описанной структуры мы считываем следующее:

\forestset{
  my tier/.style={% align all nodes on a given level
    tier/.wrap pgfmath arg={level##1}{level()},
  },
}
\begin{forest}
  for tree={
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    s sep+=-5pt,
    inner sep=2.5pt,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1{
        insert before={[, phantom, my tier]},
      }{},
    },
    my tier,
    fit=band,
    before computing xy={% change the value of l to alter the distance between levels
      l=15pt,
    },
  }
  [project-root/
    [.gshell/
      [commits/
        [master]
        [rev1-rev1Hash/
          [to-mount/]
          [commit]
          [parents]
          [time-stamp]
        ]
        [rev2-rev2Hash/
          [to-mount/]
          [commit]
          [parents]
          [time-stamp]
        ]
        [\dots]
      ]
      [work-id1/
        [work-information]
      ]
      [work-id2/
        [work-information]
      ]
    ]
    [work-id1/]
    [work-id2/]
  ]
\end{forest}

_Gshell_ - программа, которая инициализируется отдельно для каждого проекта.
Мы можем видеть нашу структуру, которая будет одинаковой по своему строению для каждого из проекта.

* _project-root_ --- изначальная папка, которая дается gshell в качестве начальной для инициализации.
* _.gshell_ - папка, в которой находятся ревизии, а так же дополнительная информация о каждой запущенной сессии.
* _commits_ - папка, в которой находятся ревизии.
* _master_ - файл, который содержит название главной ревизии.
* _rev-revhash_ - папка для ревизии. _revhash_ - случайная строка, которая создается для каждой ревизии.
* _to-mount_ - папка, которая содержит файлы пользователя, относящиеся для конкретной ревизии.
* _commit_ - файл, который содержит сообщение, поясняющие, как была создана данная ревизия.
* _parents_ - файл, содержащий в себе информацию о ревизиях, которые были предками данной. То есть те ревизии, из которых она получилась.
* _time-stamp_ - файл, содержайщий запись о том, когда ревизия получилась. Стоит отметить, что в файле записано не время создания, а момент, когда действие, необходимое для получения результата было завершено.
* _.gshell/work-id*_ - папка, которая содержит в себе информацию, необходимую для работы сессии.
* _work-information_ - файл, который содержит в себе список ревизий, которые загружены для данной сессии.
* _project-root/work-id_* - папка, в которой "находится" пользователь и в которой в данный момент загружено множество ревизий. Пользователь в ней видит только свои файлы.

### Работа со внутренней структурой ###

#### Линзы ####

Для работы со внутренней структурой была использована библиотека lens от Хмета (TODO КТО ТАКОЙ).

Данная библиотека позволяет очень просто модифицировать объекты. Например у нас есть
\inlref{листинге}{lst:store-fs} и вышеупомянутая директория проекта. Что бы получить
время создания второй ревизии без использования библиотеки lens, нам было бы необходимо
писать очень длинную рекурсивную функцию, которая бы распаковывала структуру, проверяла налицие необходимых подпапок и тд. Код получился бы очень громоздким.
Но с помощью данной библиотеки мы можем написать

\begin{code}[language=Haskell,label=lst:dirdatatree,
                   caption={}]
timeStamp name = revisionRoot name.traverse.filteredByName timeStampFileName._file
\end{code}

На вход функции мы просто даем имя интересующей нас ревизии и саму структуру.

Линзы - это функции первого класса для доступа к данным в структурах. Отдаленным
аналогом в императивных язык программирования являются getters и setters. В
русском языке правильней было бы их назвать лупой, тк они позволяют сфокусироваться
на каком-то значении. А фокусироваться нам нужно как раз для того, чтобы изменять
(set) или получать (get).

Ряд функций, для упрощения работы с состоянием программы приведен ниже:
\begin{code}[language=Haskell,label=lst:commitcode,
                   caption={}]
projectRoot = _dirTree._contents

gshellRoot = projectRoot.traverse.filteredByName gshellDirName._contents

commitsRoot = gshellRoot.traverse.filteredByName commitsDirName._contents

revisionRoot name = commitsRoot.traverse.filteredByName name._contents

workDirs = projectRoot.traverse.filteredByName workDirName

workingState name = gshellRoot.traverse.filteredByName name._contents.traverse.filteredByName workHelperFileName._file

masterState = commitsRoot.traverse.filteredByName masterFileName._file

parents name = revisionRoot name.traverse.filteredByName parentsFileName._file

timeStamp name = revisionRoot name.traverse.filteredByName timeStampFileName._file

revCommit revision = commitsRoot.traverse.filteredByName revision._contents.traverse.filteredByName commitFileName._file
\end{code}

#### Монада State  ####

Я не знаю, что тут писать :(

#### Трансформеры ####

И тут я не знаю, что писать, тк надо как то рассказать про state.
